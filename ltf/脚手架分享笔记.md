# @ttp/cli脚手架
1. 脚手架就是一个客户端程序，用来辅助我们开发并提高开发效率的工具


## 手工实现一个脚手架的基本流程
1. 在package.json中用`node  type:module` 来启用用es module

2. ```js
     "bin": {
       "ttp": "./packages/core/bin/index.js"
     },
   ```

3. 配置husky钩子

  - `npx husky install`
  - `npx husky add .husky/pre-commit  'npx lint-staged'`

3. npm init -y   项目名称改写成@ttp/cli  修改package  bin字段为 `"ttp":"bin/index.js"`

4. 创建子项目cli-core

5. 设置 cli-core子项目的package.json的`"type":"module"` 

6. npm i  -g pnpm

7. 在pnpm-workspace.yaml中添加

   ```yaml
   packages:
     - 'packages/*'
   ```

8. bin/index.js的顶部添加`#! /usr/bin/env node`

   ```js
   import init from '../src/index.js'
   init(process.argv)
   ```

   

9. pnpm i commander --filter cli-core

10. 创建commands文件夹，各种命令文件将放在此目录下，创建cli-core/index.js是此子项目的入口，将由bin/index.js来调用
    ```
    ttp2-cli                              
    ├─ packages                           
    │  ├─ core                        
    │  │  ├─ bin                          
    │  │  │  └─ index.js                  
    │  │  ├─ src                          
    │  │  │  ├─ commands                  
    │  │  │  │  ├─ create                 
    │  │  │  │  │  └─ index.js            
    │  │  │  │  ├─ mock2local             
    │  │  │  │  │  ├─ index.js            
    │  │  │  │  │  └─ inject-template.js  
    │  │  │  │  └─ server                 
    │  │  │  │     ├─ index.js            
    │  │  │  │     └─ tools.js            
    │  │  │  ├─ utils                     
    │  │  │  │  └─ common.js              
    │  │  │  └─ index.js                  
    │  │  └─ package.json                 
    │  └─ mock-server                     
    │     ├─ src                          
    │     │  └─ index.js                  
    │     └─ package.json                 
    ├─ package.json                       
    ├─ pnpm-lock.yaml                     
    └─ pnpm-workspace.yaml
    ```

#### 一、 实现ttp server命令
1. packages/cli-core/index.js文件如下

2. program.version函数定义获取版本号命令
   - `  program.version(NOW_VERSION, '-v, --version')`

3. 定义脚手架命令：ttp server

   - `command('server [config...]')`定义命令格式，ttp server后面可以跟其他选项也可以不跟

   - `description('启动一个本地的 webpack-dev-server')`  简述命令功能在帮助文档中显示

   - `option('-t, --target <url>', '指定代理地址')` 命令可选参数

   - `action()`输入命令后的回调函数config参数是

     - ```js
       import { Command } from 'commander'
       import path from 'path'
       
       import { readJsonFile, extractModuleMeta, strMapFile } from './utils/common.js'
       const { rootPath } = extractModuleMeta(import.meta.url, '../')
       const program = new Command()
       const { version: NOW_VERSION } = readJsonFile(
         path.join(rootPath, 'package.json')
       )
       const ttpCommandMap = strMapFile(path.join(rootPath, 'src/commands'))
       export default (argv) => {
         program.version(NOW_VERSION, '-v, --version')
         program
           .command('server [config...]')
           .description('启动一个本地的 webpack-dev-server')
           .option('-t, --target <url>', '指定代理地址')
           .action((config, option) => {
             ttpCommandMap('server', option)
           })
         program.parse(argv)
       
       }
       ```
   
   - src/utils/common.js文件
   
     添加reandJsonFile函数读取json文件并转化成对象
   
     - ```js
       import fs from 'fs'
       import path from 'path'
       import { fileURLToPath } from 'url'
       
       export function readJsonFile(filePath) {
         return JSON.parse(fs.readFileSync(filePath))
       }
       export function extractModuleMeta(importMetaUrl, rootRelativePath = '../../') {
         const __filename = fileURLToPath(importMetaUrl)
         const __dirname = path.dirname(__filename)
         return {
           __dirname,
           __filename,
           rootPath: path.join(__dirname, rootRelativePath),
         }
       }
       export function strMapFile(fatherPath) {
         return (command, ...nextArgs) => {
           const modulePath = path.resolve(fatherPath, command, 'index.js')
           import(modulePath).then((module) => {
             module.default(...nextArgs)
           })
         }
       }
       
       ```
     
   - commands/server/index.js
   
     ```js
     import path from 'path'
     async function getCurrentNodeModuleLib(libPath) {
       let res = await import(
         path.resolve(path.join(process.cwd(), 'node_modules', libPath))
       )
       return res
     }
     
     const getWebpackConfig = async function (config) {
       const configModule = await import(path.resolve(`webpack.config${config}.js`))
       return configModule.default
     }
     
     let { default: webpack } = await getCurrentNodeModuleLib('webpack/lib/index.js')
     let { default: Server } = await getCurrentNodeModuleLib(
       'webpack-dev-server/lib/Server.js'
     )
     let { default: processOptions } = await getCurrentNodeModuleLib(
       'webpack-dev-server/lib/utils/processOptions.js'
     )
     
     const startDevServer = (config, options) => {
       let compiler = webpack(config)
       let server = new Server(compiler, options)
       server.listen(options.port, options.host)
     }
     
     const initService = async (commandOpt) => {
       const type = 'server'
       const webpackConfig = await getWebpackConfig(`.${type}`)
       processOptions(webpackConfig, {}, startDevServer)
     }
     
     export default async function (commandOpt) {
       initService(commandOpt)
     }
     
     ```
   
     



#### 二、mock2local命令实现

1. 添加命令定义

   - ```js
         program
           .command('mock2local [config...]')
           .description('自动mock接口数据到本地保存，并自动生成对应接口')
           .option('-e, --entry <path>', '指定要mock数据的页面路径')
           .option('-p, --proxy [port]', '代理接口到本地')
           .option('-rm, --remove', '停止mock接口数据到本地并删除注入代码')
           .action(async (config, option) => {
           ttpCommandMap('mock2local', config, option)
         })
     ```
     
     

2. 在commands/mock2local文件夹下定义真正执行命令的文件

   - index.js文件

     - ```js
       import fs from 'fs'
       import path from 'path'
       import nodemon from 'nodemon'
       import { extractModuleMeta } from '../../utils/common.js'
       const { rootPath, __dirname } = extractModuleMeta(import.meta.url, '../../../')
       import removeProxy from './remove.js'
       export default function init(config, option) {
         const { entry, proxy, remove } = option
         const outputPath = path.join(process.cwd(), `${entry}`)
         let template = fs.readFileSync(
           path.resolve(__dirname, 'inject-template.js'),
           'utf-8'
         )
         const templateProxy = fs.readFileSync(
           path.resolve(__dirname, 'inject-proxy-template.js'),
           'utf-8'
         )
         if (remove) {
           return removeProxy(outputPath, template, templateProxy)
         }
         startNodemon(rootPath, entry, outputPath, template, templateProxy)
       
         let prependContent = proxy ? templateProxy : template
         let originalContent = fs.readFileSync(outputPath, 'utf-8')
         if (originalContent.includes(template)) {
           originalContent = originalContent.replace(template, '')
         } else if (originalContent.includes(templateProxy)) {
           originalContent = originalContent.replace(templateProxy, '')
         }
         const newContent = prependContent.trim() + '\n' + originalContent
         try {
           fs.writeFileSync(outputPath, newContent)
           console.log('文件更新成功:', outputPath)
         } catch (err) {
           console.error('文件更新失败:', err)
         }
       }
       
       function startNodemon(rootPath, entry, outputPath, template, templateProxy) {
         nodemon({
           script: path.resolve(rootPath, '../', 'mock-server/src/index.js'),
           ext: 'js',
           watch: [
             path.resolve(rootPath, '../', 'mock-server'),
             path.join(process.cwd(), 'mock'),
           ],
           args: [process.cwd(), entry],
         })
         nodemon
           .on('start', function () {})
           .on('quit', function () {
             removeProxy(outputPath, template, templateProxy)
             console.log('mock服务器停止')
             process.exit()
           })
           .on('restart', function (files) {
             console.log('mock服务器重启: ', files)
           })
       }
       
       
       ```

   - inject-template.js，用来劫持接口数据存储到本地

     ```js
     const originalFetch = fetch
     function stripQueryParams(url) {
       return url.replace(/\?.*$/, '')
     }
     window.fetch = async (url, options = {}) => {
       await mockData()
       async function mockData() {
         let res = await originalFetch(url, options)
         let data = await res.json()
         let mock2localUrl = 'http://localhost:9998/mock2local'
         url = stripQueryParams(url)
         let params = {
           url,
           method: options.method ? options.method : 'get',
           data,
         }
         res = await originalFetch(mock2localUrl, {
           method: 'POST',
           headers: {
             'Content-Type': 'application/json',
           },
           body: JSON.stringify(params),
         })
       }
       return originalFetch(url, options)
     }
     
     let createElement = document.createElement.bind(document)
     
     document.createElement = function (...args) {
       if (args[0] === 'script') {
         let srcEle = createElement('script')
         let setAttribute = srcEle.setAttribute.bind(srcEle)
         srcEle.setAttribute = function (src, value) {
           if (value.includes('selectRightMenu') || value.includes('Left')) {
             value = 'http://localhost:9998/selectRightMenu?url=' + value
           }
           return setAttribute(src, value)
         }
         return srcEle
       }
       return createElement(...args)
     }
     
     ```
     
   - inject-proxy-template.js文件，用来代理接口请求转发到本地服务器

     ```js
     const originalFetch = fetch
     
     window.fetch = async (url, options = {}) => {
       return originalFetch(`http://localhost:9998${url}`, options)
     }
     
     let createElement = document.createElement.bind(document)
     
     document.createElement = function (...args) {
       if (args[0] === 'script') {
         let srcEle = createElement('script')
         let setAttribute = srcEle.setAttribute.bind(srcEle)
         srcEle.setAttribute = function (src, value) {
           if (value.includes('selectRightMenu') || value.includes('Left')) {
             value = 'http://localhost:9998/selectRightMenu?url=' + value
           }
           return setAttribute(src, value)
         }
         return srcEle
       }
       return createElement(...args)
     }
     
     ```

   - remove.js用来移除添加到页面上的劫持代码

     ```js
     import fs from 'fs'
     
     export default function remove(outputPath, template, templateProxy) {
       let originalContent = fs.readFileSync(outputPath, 'utf-8')
       if (originalContent.includes(template)) {
         originalContent = originalContent.replace(template, '')
       } else if (originalContent.includes(templateProxy)) {
         originalContent = originalContent.replace(templateProxy, '')
       }
       try {
         fs.writeFileSync(outputPath, originalContent)
         console.log('文件更新成功:', outputPath)
       } catch (err) {
         console.error('文件更新失败:', err)
       }
     }
     
     ```

     

3. 添加子项目mock-server并在在cli-core中添加mock-server子项目包`pnpm add 'mock-server@workspace:*' `

4. - 添加依赖`pnpm i koa @koa/router @koa/bodyparser @koa/cors async-mutex -S --filter mock-server`并添加`  "type": "module",`生成如下package.json

     ```json
     {
       "name": "mock-server",
       "version": "1.0.0",
       "description": "",
       "main": "index.js",
       "scripts": {
         "test": "echo \"Error: no test specified\" && exit 1"
       },
       "type": "module",
       "keywords": [],
       "author": "",
       "license": "ISC",
       "dependencies": {
         "@koa/bodyparser": "^5.0.0",
         "@koa/cors": "^4.0.0",
         "@koa/router": "^12.0.0",
         "async-mutex": "^0.4.0",
         "koa": "^2.14.2"
       }
     }
     
     
     ```
   
   - 添加启动文件index.js
   
     ```js
     import koa from 'koa'
     import Router from '@koa/router'
     import bodyParser from '@koa/bodyparser'
     import cors from '@koa/cors'
     
     import initRouter from './routers/index.js'
     
     let app = new koa()
     let router = new Router()
     app.use(bodyParser())
     
     app.use(
       cors({
         origin: '*',
         allowMethods: ['GET', 'POST', 'PUT', 'DELETE'],
         credentials: true,
       })
     )
     
     initRouter(app, process.argv[2])
     
     app.use(router.routes())
     
     app.listen(9998, () => {
       console.log('-----mock server start------')
     })
     
     ```
   
   - 添加路由自动生成文件
   
     ```js
     import fs, { promises as fsPromise } from 'fs'
     import path from 'path'
     import Router from '@koa/router'
     import { Mutex } from 'async-mutex'
     const mutex = new Mutex()
     
     export default async function initRouter(app, dirPath) {
       let files = await fsPromise.readdir(dirPath, { withFileTypes: true })
       for (const file of files) {
         if (file.name == 'mock') {
           await addMockRouters(app, path.join(dirPath, file.name))
           break
         }
       }
       addMock2LocalRouter(app)
     }
     
     async function addMock2LocalRouter(app) {
       const router = new Router()
       router.post('/mock2local', async (ctx) => {
         const { url, method, data } = ctx.request.body
         try {
           await createOrAppendMockRouter(url, method, data)
           ctx.body = 'success'
         } catch (e) {
           ctx.body = 'erro'
         }
       })
       app.use(router.routes())
     }
     
     async function addMockRouters(app, dirPath) {
       let files = await fsPromise.readdir(dirPath, { withFileTypes: true })
       for (const file of files) {
         const filePath = path.resolve(dirPath, file.name)
         if (file.isDirectory()) {
           return addMockRouters(app, filePath)
         }
         const routerModule = await import(filePath)
         if (routerModule.default) {
           const router = new Router()
           routerModule.default(router)
           app.use(router.routes())
         }
       }
     }
     
     async function createOrAppendMockRouter(url, method, data) {
       const [cwd, mockEntry] = process.argv.slice(2)
     
       const [, moduleDir, , entryDir] = mockEntry.split('/')
     
       let filePath = path.join(cwd, 'mock', moduleDir, entryDir)
       let fileDir = path.join(cwd, 'mock', moduleDir)
       let template = ''
     
       const release = await mutex.acquire()
       const routeEndMatcher = new RegExp(
         `router.${method.toLowerCase()}\\('${url}'[\\s\\S]*?\\}\\)`
       )
     
       try {
         if (fs.existsSync(filePath)) {
           const content = await fsPromise.readFile(filePath, 'utf-8')
           template = `
                 router.${method.toLowerCase()}('${url}', (ctx)=>{
                     ctx.body = ${JSON.stringify(data)}
                 })
                 `
           let newContent = ''
     
           if (routeEndMatcher.test(content)) {
             newContent = content.replace(routeEndMatcher, template)
           } else {
             const insertPosition = content.lastIndexOf('}')
             newContent = [
               content.slice(0, insertPosition),
               template,
               content.slice(insertPosition),
             ].join('\n')
           }
     
           await fsPromise.writeFile(filePath, newContent)
         } else {
           template = `module.exports=function(router){
     
             }`
           fs.mkdirSync(fileDir, { recursive: true })
           await fsPromise.writeFile(filePath, template)
         }
       } finally {
         release()
       }
     }
     
     ```



#### 三、2vue3

1. 添加命令定义

   ```js
     program
       .command('2vue3 [config...]')
       .description('vue2语法代码转换vue3')
       .action((config, option) => {
         ttpCommandMap('2vue3', config, option)
       })
   ```

 2. 命令处理文件 2vue3/index.js

    ```js
    import path from 'path'
    import inquirer from 'inquirer'
    import { wrapLoading } from '../../utils/loading.js'
    import messageFun from './choices/message/index.js'
    import definePropertyFun from './choices/define-property/index.js'
    
    export default async function (targetPath) {
      const cwd = process.cwd()
      let { action } = await inquirer.prompt([
        {
          name: 'action',
          type: 'list',
          message: '请选择：',
          choices: [
            { name: '$message语法替换', value: '$message' },
            { name: 'defineProperty特性替换', value: 'defineProperty' },
          ],
        },
      ])
      if (action === '$message') {
        await wrapLoading('执行中...', () => messageFun(targetPath))
      } else if (action === 'defineProperty') {
        let { action } = await inquirer.prompt([
          {
            name: 'action',
            type: 'list',
            message: '请选择：',
            choices: [
              { name: '$set语句删除', value: '$set' },
              { name: '$delete语句删除', value: '$delete' },
            ],
          },
          {
            name: 'confirmation',
            type: 'confirm',
            message: '您确定要继续吗？',
          },
        ])
        console.log(action, targetPath)
        await wrapLoading('执行中...', () => definePropertyFun(targetPath, action))
      }
    }
    
    ```

    

 3. choices/message.js

    ```js
    import path from 'path'
    import fs from 'fs'
    function convertMessageFormat(input) {
      // 当message和type属性存在，而且type在前面时
      input = input.replace(
        /this\.\$message\(\{\s*type\s*:\s*["'](\w+?)["'],\s*message\s*:\s*([^}]+)\s*\}\)/g,
        (match, type, message) => {
          return `Message.${type}(${message.trim()})`
        }
      )
    
      // 当message和type属性存在，而且message在前面时
      input = input.replace(
        /this\.\$message\(\{\s*message\s*:\s*([^,}]+),\s*type\s*:\s*["'](\w+?)["']\s*\}\)/g,
        (match, message, type) => {
          return `Message.${type}(${message.trim()})`
        }
      )
    
      // 当只有message属性存在时
      input = input.replace(
        /this\.\$message\(\{\s*message\s*:\s*([^}]+)\s*\}\)/g,
        (match, message) => {
          return `Message(${message.trim()})`
        }
      )
    
      // 移除 Vue.use(Message);
      input = input.replace(/Vue\.use\(Message\);\s*/g, '')
    
      return input
    }
    function replaceVue2Methods(code) {
      // 移除 this.$set
      let newCode = code.replace(
        /this\.\$set\(([^,]+),\s*([^,]+),\s*([^)]+)\)/g,
        (match, object, key, value) => {
          return `${object}[${key}] = ${value}`
        }
      )
    
      // 移除 this.$delete
      newCode = newCode.replace(
        /this\.\$delete\(([^,]+),\s*([^)]+)\)/g,
        (match, object, key) => {
          return `delete ${object}[${key}]`
        }
      )
    
      return newCode
    }
    
    export default function (targetPath) {
      return new Promise((resolve, reject) => {
        const targetFile = fs.readFileSync(
          path.resolve(process.cwd(), targetPath[0]),
          'utf-8'
        )
        const output = convertMessageFormat(targetFile)
        fs.writeFileSync(path.resolve(process.cwd(), targetPath[0]), output)
        resolve()
      })
    }
    
    ```

    

 4. utils/loading.js

    ```js
    import ora from 'ora'
    export const wrapLoading = async (message, fn, successMessage = '完成') => {
      const spinner = ora(message)
      spinner.start()
      try {
        const res = await fn()
        spinner.succeed(successMessage)
        return res
      } catch (err) {
        spinner.fail('执行失败')
      }
    }
    
    ```

    

 5. choices/define-property.js

    ```js
    import path from 'path'
    import fs from 'fs'
    function replaceVue2Methods(code, action) {
      let newCode = ''
      if (action == '$set') {
        // 移除 this.$set
        newCode = code.replace(
          /this\.\$set\(([^,]+),\s*([^,]+),\s*([^)]+)\)/g,
          (match, object, key, value) => {
            return `${object}[${key}] = ${value}`
          }
        )
      } else if (action == '$delete') {
        // 移除 this.$delete
        newCode = newCode.replace(
          /this\.\$delete\(([^,]+),\s*([^)]+)\)/g,
          (match, object, key) => {
            return `delete ${object}[${key}]`
          }
        )
      }
    
      return newCode
    }
    export default function (targetPath, action) {
      return new Promise((resolve, reject) => {
        console.log(path.resolve(process.cwd(), targetPath[0]), action)
        const targetFile = fs.readFileSync(
          path.resolve(process.cwd(), targetPath[0]),
          'utf-8'
        )
        const output = replaceVue2Methods(targetFile, action)
        fs.writeFileSync(path.resolve(process.cwd(), targetPath[0]), output)
        resolve()
      })
    }
    
    ```

#### 四、create

1. 命令定义

   ```js
     program
       .command('create <project-name>')
       .description('create a project')
       .option('-f, --force', 'overwrite target directory')
       .action(async (config, cmd) => {
         ttpCommandMap('create', config, cmd)
       })
   ```

   

2. create/index.js

   ```js
   import { existsSync, rmSync } from 'fs'
   import path from 'path'
   import inquirer from 'inquirer'
   import { wrapLoading } from '../../utils/loading.js'
   import {
     cloneAndCheckoutTag,
     getOrganizationProjects,
     getProjectVersions,
   } from './remote.js'
   export default async function (name, option) {
     const cwd = process.cwd()
     const targetDir = path.join(cwd, name)
     if (existsSync(targetDir)) {
       if (option.force) {
         rmSync(targetDir, { recursive: true })
       } else {
         let { action } = await inquirer.prompt([
           {
             name: 'action',
             type: 'list',
             message: '目录存在了是否要覆盖',
             choices: [
               { name: 'overwrite', value: 'overwrite' },
               { name: 'cancel', value: false },
             ],
           },
         ])
         if (!action) {
           return console.log('用户取消创建')
         }
         if (action === 'overwrite') {
           await wrapLoading('remove', () =>
             rmSync(targetDir, { recursive: true })
           )
         }
       }
     }
     let projects = await getOrganizationProjects()
     let { projectName } = await inquirer.prompt([
       {
         name: 'projectName',
         type: 'list',
         message: '请选择项目列表',
         choices: projects,
       },
     ])
     let tags = await getProjectVersions(projectName)
   
     let { tag } = await inquirer.prompt([
       {
         name: 'tag',
         type: 'list',
         message: '请选择对应的版本',
         choices: tags,
       },
     ])
     await cloneAndCheckoutTag(tag, projectName, name)
   }
   
   ```

   

3. commands/create/remote.js

   ```js
   import axios from 'axios'
   import { exec } from 'child_process'
   import { wrapLoading } from '../../utils/loading.js'
   import util from 'util'
   import { rm } from 'fs/promises'
   const execPromisified = util.promisify(exec)
   
   const accessToken = '32a50c14a4c02ed37aabd22ea7360806'
   const organization = 'dreamneverdie_1'
   export async function getOrganizationProjects() {
     const res = await axios.get(
       `https://gitee.com/api/v5/orgs/${organization}/repos`,
       {
         headers: {
           Authorization: `Bearer ${accessToken}`,
         },
       }
     )
     return res.data.map((item) => item.name)
   }
   
   export async function getProjectVersions(repo) {
     const res = await axios.get(
       `https://gitee.com/api/v5/repos/${organization}/${repo}/tags`,
       {
         headers: {
           Authorization: `Bearer ${accessToken}`,
         },
       }
     )
     return res.data.map((item) => item.name)
   }
   
   export async function cloneAndCheckoutTag(tag, projectName, repo) {
     const cmd = `git clone --branch ${tag} --depth 1 https://gitee.com/${organization}/${projectName}.git ${repo}`
   
     return wrapLoading('create project', async () => {
       await execPromisified(cmd)
       return rm(`${repo}/.git`, { recursive: true })
     })
   }
   
   ```

   



